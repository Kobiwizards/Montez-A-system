import { useState, useEffect, useCallback } from 'react'
import { useAnalyticsStore } from '@/store/analytics.store'
import { api } from '@/lib/api/client'

// Match EXACT types from store
interface AnalyticsData {
  summary: {
    totalTenants: number
    totalUnits: number
    occupancyRate: number
    totalRentDue: number
    totalRentPaid: number
    totalWaterDue: number
    totalWaterPaid: number
    pendingPayments: number
    verifiedPayments: number
  }
  monthlyTrends: Array<{
    month: string
    rentCollected: number
    rentDue: number
    waterCollected: number
    waterDue: number
    newTenants: number
    vacancies: number
  }>
  tenantStatus: {
    current: number
    overdue: number
    delinquent: number
    evicted: number
    former: number
  }
  unitStatus: {
    occupied: number
    vacant: number
    maintenance: number
  }
}

interface AnalyticsFilters {
  startDate?: string
  endDate?: string
  unitType?: string
  status?: string
  apartment?: string
}

type ExportFormat = 'csv' | 'pdf' | 'excel'

export function useAnalytics() {
  const {
    dashboardData,
    occupancyData,
    financialData,
    isLoading,
    error,
    dateRange,
    setDashboardData,
    setOccupancyData,
    setFinancialData,
    setLoading,
    setError,
    setDateRange,
  } = useAnalyticsStore()

  // Fetch dashboard data
  const fetchDashboardData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      
      const response = await api.get<any>('/analytics/dashboard')
      
      const data = response as any
      
      if (data.success && data.data) {
        const apiData = data.data
        
        // Transform monthly trends
        const monthlyTrends = Array.isArray(apiData.monthlyTrends) 
          ? apiData.monthlyTrends.map((trend: any) => ({
              month: trend.month || '',
              rentCollected: trend.rentCollected || trend.revenue || 0,
              rentDue: trend.rentDue || 0,
              waterCollected: trend.waterCollected || 0,
              waterDue: trend.waterDue || 0,
              newTenants: trend.newTenants || 0,
              vacancies: trend.vacancies || 0,
            }))
          : []
        
        // Create AnalyticsData matching EXACT store type
        const dashboardData: AnalyticsData = {
          summary: {
            totalTenants: apiData.totalTenants || apiData.summary?.totalTenants || 0,
            totalUnits: apiData.totalUnits || apiData.summary?.totalUnits || 0,
            occupancyRate: apiData.occupancyRate || apiData.summary?.occupancyRate || 0,
            totalRentDue: apiData.totalRentDue || apiData.summary?.totalRentDue || 0,
            totalRentPaid: apiData.totalRentPaid || apiData.summary?.totalRentPaid || 0,
            totalWaterDue: apiData.totalWaterDue || apiData.summary?.totalWaterDue || 0,
            totalWaterPaid: apiData.totalWaterPaid || apiData.summary?.totalWaterPaid || 0,
            pendingPayments: apiData.pendingPayments || apiData.summary?.pendingPayments || 0,
            verifiedPayments: apiData.verifiedPayments || apiData.summary?.verifiedPayments || 0,
          },
          monthlyTrends,
          tenantStatus: {
            current: apiData.tenantStatus?.current || apiData.currentTenants || 0,
            overdue: apiData.tenantStatus?.overdue || apiData.overdueTenants || 0,
            delinquent: apiData.tenantStatus?.delinquent || apiData.delinquentTenants || 0,
            evicted: apiData.tenantStatus?.evicted || apiData.evictedTenants || 0,
            former: apiData.tenantStatus?.former || 0, // Added missing property
          },
          unitStatus: {
            occupied: apiData.unitStatus?.occupied || apiData.occupiedUnits || 0,
            vacant: apiData.unitStatus?.vacant || apiData.vacantUnits || 0,
            maintenance: apiData.unitStatus?.maintenance || apiData.maintenanceUnits || 0,
          },
        }
        
        setDashboardData(dashboardData)
        return { success: true, data: dashboardData }
      } else {
        return { 
          success: false, 
          error: data.message || 'Failed to fetch dashboard data' 
        }
      }
    } catch (error: any) {
      const errorMessage = error.message || 'Failed to fetch dashboard data'
      setError(errorMessage)
      return { 
        success: false, 
        error: errorMessage 
      }
    } finally {
      setLoading(false)
    }
  }, [setLoading, setError, setDashboardData])

  // Fetch occupancy analytics
  const fetchOccupancyData = useCallback(async (filters?: AnalyticsFilters) => {
    try {
      setLoading(true)
      setError(null)
      
      const params = new URLSearchParams()
      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined && value !== '') {
            params.append(key, String(value))
          }
        })
      }

      const response = await api.get<any>(`/analytics/occupancy?${params}`)
      
      const data = response as any
      
      if (data.success && data.data) {
        setOccupancyData(data.data)
        return { success: true, data: data.data }
      } else {
        return { 
          success: false, 
          error: data.message || 'Failed to fetch occupancy data' 
        }
      }
    } catch (error: any) {
      const errorMessage = error.message || 'Failed to fetch occupancy data'
      setError(errorMessage)
      return { 
        success: false, 
        error: errorMessage 
      }
    } finally {
      setLoading(false)
    }
  }, [setLoading, setError, setOccupancyData])

  // Fetch financial analytics
  const fetchFinancialData = useCallback(async (filters?: AnalyticsFilters) => {
    try {
      setLoading(true)
      setError(null)
      
      const params = new URLSearchParams()
      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined && value !== '') {
            params.append(key, String(value))
          }
        })
      }

      const response = await api.get<any>(`/analytics/financial?${params}`)
      
      const data = response as any
      
      if (data.success && data.data) {
        setFinancialData(data.data)
        return { success: true, data: data.data }
      } else {
        return { 
          success: false, 
          error: data.message || 'Failed to fetch financial data' 
        }
      }
    } catch (error: any) {
      const errorMessage = error.message || 'Failed to fetch financial data'
      setError(errorMessage)
      return { 
        success: false, 
        error: errorMessage 
      }
    } finally {
      setLoading(false)
    }
  }, [setLoading, setError, setFinancialData])

  // Generate report
  const generateReport = async (type: string, filters: AnalyticsFilters) => {
    try {
      setLoading(true)
      setError(null)
      
      const response = await api.post<any>('/analytics/report', { type, ...filters })
      
      const data = response as any
      
      if (data.success && data.data) {
        return { success: true, data: data.data }
      } else {
        return { 
          success: false, 
          error: data.message || 'Failed to generate report' 
        }
      }
    } catch (error: any) {
      const errorMessage = error.message || 'Failed to generate report'
      setError(errorMessage)
      return { 
        success: false, 
        error: errorMessage 
      }
    } finally {
      setLoading(false)
    }
  }

  // Export data
  const exportData = async (type: string, format: ExportFormat, filters?: AnalyticsFilters) => {
    try {
      setLoading(true)
      setError(null)
      
      const params = new URLSearchParams({ type, format })
      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined && value !== '') {
            params.append(key, String(value))
          }
        })
      }

      const response = await api.get<any>(`/analytics/export?${params}`, {
        responseType: 'blob'
      })
      
      if (response instanceof Blob) {
        const url = window.URL.createObjectURL(response)
        const a = document.createElement('a')
        a.href = url
        a.download = `report-${type}-${new Date().toISOString().split('T')[0]}.${format}`
        document.body.appendChild(a)
        a.click()
        window.URL.revokeObjectURL(url)
        document.body.removeChild(a)
        
        return { success: true }
      } else {
        return { 
          success: false, 
          error: 'Failed to download export' 
        }
      }
    } catch (error: any) {
      const errorMessage = error.message || 'Failed to export data'
      setError(errorMessage)
      return { 
        success: false, 
        error: errorMessage 
      }
    } finally {
      setLoading(false)
    }
  }

  // Fetch dashboard data on mount
  useEffect(() => {
    fetchDashboardData()
  }, [fetchDashboardData])

  return {
    dashboardData,
    occupancyData,
    financialData,
    isLoading,
    error,
    dateRange,
    setDateRange,
    fetchDashboardData,
    fetchOccupancyData,
    fetchFinancialData,
    generateReport,
    exportData,
  }
}